package lectureNotes;

public class ThreadsOfExecution {}

/*
    Потоки выполнения#
    Всё это время мы работали в однопоточной среде, то есть предполагалось, что в один и тот же момент времени
    выполняется одно действие. Такой подход не всегда подходит, и иногда нужно исполнять несколько операций в один
    момент времени. Особенно актуально это, если ваша программа исполняется на многоядерном процессоре. Чтобы полностью
    загрузить процессор работой, нужен другой подход. Такой подход называется многопоточностью. Идея такова, что мы
    разбиваем исполнение нашей программы на несколько параллельных потоков исполнения. Каждый поток исполняется
    независимо друг от друга. И если у нас есть возможность запустить разные потоки на разных процессорных ядрах, то
    чаще всего мы получим увеличение производительности.

    Первый поток при вызове main#
    Таким образом, запущенная Java-программа всегда состоит минимум из одного потока. Этот поток создается во время
    старта программы (при запуске метода public static void main(String[] args)). Дальше во время исполнения программы
    мы можем стартовать и останавливать дополнительные потоки. Программа завершается, если не остается ни одного
    активного потока.

    Класс Thread#
    В Java для организации кода в поток есть класс Thread. По своей сути поток - это легковесный процесс, у которого
    есть собственный стек вызовов. Во всем остальном класс Thread - обычный класс, и работа с ним аналогична работе
    с другими классами. Поскольку любой код исполняется в каком-то потоке, мы можем получить текущий поток, в котором
    выполняется код, вызвав метод Thread.currentThread(). Для разных потоков вызов этого метода будет возвращать разные
    объекты. Есть два способа запустить код в отдельном потоке, используя класс Thread - унаследуясь от этого класса,
    и передав в этот класс экземпляр класса Runnable.

    Наследование от класса Thread#
    В этом случае мы определяем новый класс HelloThread, и переопределяем в нем метод run().
*/
    class HelloThread extends Thread {
        @Override
        public void run() {
            System.out.println("Hello from thread");
        }
    }
/*

    Передача Runnable#
    Более удобный способ создания потока - передать классу Thread при создании, экземпляр типа Runnable:
*/
    class Test {
        public static void main(String[] args) {
            Thread helloThread = new Thread(new Runnable() {
                @Override
                public void run() {
                    System.out.println("Hello");
                }
            });
        }
    }
/*
    Используя лямбда-выражения, этот же код можно записать компактней и наглядней:
*/
    class Test1 {
        public static void main(String[] args) {
            Thread helloThread = new Thread(() -> System.out.println("Hello"));
        }
    }
/*
    ПОЛЕЗНО
    Создание новых потоков с передачей нужного кода в лямбда-выражениях - один из наиболее удобных способов.

    Запуск потока#
    Для запуска потока нужно у объекта потока вызвать метод start(). Вот пример создания потока, и запуска этого потока:
*/
    class HelloThread1 extends Thread {
        @Override
        public void run() {
            System.out.println("Hello from thread");
        }
    }

    class ThreadTest {
        public static void main(String[] args) {
            new HelloThread1().start();
        }
    }
/*
    Код выше выведет в консоль: Hello from thread.

    Если переписать этот же код с лямбдами, получится короче и наглядней:
*/
    class ThreadTest1 {
        public static void main(String[] args) {
            new Thread(() -> System.out.println("Hello from thread")).start();
        }
    }
/*
    ВНИМАНИЕ
    Частая ошибка новичков - вызывают метод run() вместо метода start(). Код выполнится, но в текущем потоке
    (потому что по факту вы вызвали метод другого класса в этом же потоке).

    Состояния потоков#
    Поток может находиться в одном из 6 состояний:
        1) Экземпляр потока создан и может быть запущен (new). Способы создания и запуска мы рассмотрели выше.
        2) Поток выполняется (runnable)
        3) Выполнение потока приостановлено (waiting)
        4) Выполнение потока приостановлено на время (timed waiting)
        5) Выполнение потока заблокировано (blocked)
        6) Поток закончил выполнение (terminated)
    -------------------------------------------------------------------------------------------------------------------
                                                    Состояние потока
                                                                                                Ожидает окончания
                                                                                      ->          другого потока
                                                                                   /       /       (WAITING)
                                                                   join, wait /         / notify
                                                                         /           /
       new         Создан         start            Выполняется       /            /
      ---------->   (NEW)  -------------------->    (RUNNABLE)         <-      <-
                                                /   ^     |    \          \
                        stop, interrupt     /       |     |        \           \
                        Завершение run  /           |     |lock        \             \Пр истечению времени, resume
                                    /         unlock|     |                \               \
                                /                   |     v       yuld, sleep(t)\                \
             (TERMINATED)   <-                     (BLOCKED)                        \ -> (TIMED_WAITING)
               Завершен                            Блокирован                         Ожидает заданное время
    -------------------------------------------------------------------------------------------------------------------

    Выполнение потока#
    Когда мы вызываем метод start(), выполняются следующие действия:
        1) стартует новый поток выполнения;
        2) состояние потока изменяется на runnable
        3) начинается выполнение метода run() (по решению планировщика ОС)

    ВНИМАНИЕ
    Если повторно вызвать метод start() у потока, будет сгенерировано исключение IllegalThreadStateException.

    При выходе из метода run() поток завершается. Данные этого потока (стек) очищаются.

    Приостановка выполнения потока#
    Поток можно приостановить, вызвав метод wait(). Тогда поток переходит в состояние waiting, и код в нем перестает
    исполняться. Чтобы продолжить выполнение этого потока, нужно вызвать метод notify(). Вот пример, где мы создали
    поток printThread, запустили его. Дальше подождали 2 секунды (Thread.sleep(2000)), и возобновили исполнение потока.
    В консоль с интервалом в 2 секунды выведется вначале текст Exec thread, потом Finish exec thread. Обратите внимание,
    что запуск (start()), приостановка (wait()) и возобновление (notify()) потока endlessThread осуществляется из
    другого потока - того, что был запущен при запуске метода main. Также в коде есть блоки синхронизации synchronized,
    их мы разберем в следующем разделе.
*/
    class ThreadTest2 {
        public static void main(String[] args) throws InterruptedException { // Запускал_ка с исключением
            Thread printThread = new Thread(() -> { // Новый поток
                System.out.println("Exec thread"); // Печать в консоль

                synchronized (Thread.currentThread()) { // Синхронизированный поток. (Получить текущий поток)
                    try { // Начало блока кода, который потенциально может привести к ошибке
                        Thread.currentThread().wait(); // Приостановить поток
                    } catch (InterruptedException e) { // Перехват и обработка исключений
                        e.printStackTrace(); // Печатать сообщение ошибки в стек_трейс
                    }
                }

                System.out.println("Finish exec thread"); // Печать в консоль
            });

            printThread.start(); // Запуск нашего потока

            Thread.sleep(2000); // Подождать 2 секунды

            synchronized (printThread) { // Синхронизированный. Наш созданный поток
                printThread.notify(); // Продолжить выполнение этого потока
            }
        }
    }
/*

    ВНИМАНИЕ
    Управление потоками методами wait() и notify() чаще всего плохая идея, это низкоуровневый подход, и легко допустить
    ошибку. Более правильным подходом будет использование стандартной библиотеки concurrency, которую разберем дальше.

    Завершение потока#
    После выполнения тела метода run() поток переходит в состояние terminated. При попытке повторного запуска такого
    потока будет сгенерировано исключение. Чтобы вручную остановить поток, есть метод interrupt(). Выполнение этого
    метода не останавливает поток, а лишь устанавливает статус потока, что его нужно завершить. Этот статус можно
    проверить, вызвав метод isInterrupted().

    Вот пример ручного завершения потока:
*/
    class ThreadTest3 {
       public static void main(String[] args) throws InterruptedException { // Запускал_ка с исключением
           Thread endlessThread = new Thread() { // Новый поток
               @Override // Метка переопределения
               public void run() {
                   while(!isInterrupted()) { // Пока нет статуса у потока
                       System.out.println("Running..."); // Печать в консоль
                   }
               }
           };

           endlessThread.start(); // Запуск потока

           Thread.sleep(2000); // Подождать 2 секунды

           endlessThread.interrupt(); // Установит статус для потока (завершить)
       }
    }
/*
    В примере выше поток endlessThread в цикле печатает текст Running.... Другой поток, после запуска этого, ждет две
    секунды, и вызывает метод interrupt() для потока endlessThread. После этого цикл внутри потока endlessThread
    завершается, и завершается исполнение всей программы.

    Если поток находился в режиме ожидания (был вызван метод Thread.sleep()), и в этот момент для этого потока был
    вызван метод interrupt(), то сгенерируется исключение ThreadInterruptException. Его можно перехватить и обработать.

    ВНИМАНИЕ
    Также есть устаревший и не рекомендуемый к использованию (deprecated) метод stop(). Он принудительно завершает
    поток. Этот метод опасен, потому что может оставить программу в непредсказуемом состоянии.

    Приоритет потоков#
    У каждого потока есть приоритет. Это число от 1 до 10 (по умолчанию 5). Чем выше приоритет, тем вероятней поток с
    таким приоритетом выполнится раньше потока с более низким приоритетом. Задать приоритет можно методом setPriority(),
    получить приоритет потока - методом getPriority().

    Например, так можно получить приоритет текущего потока:
*/
    class ThreadTest4 {
        public static void main(String[] args) throws InterruptedException {
            System.out.println(Thread.currentThread().getPriority());
        }
    }
/*
    В консоль выведется число (скорей всего 5) - приоритет текущего потока.

    ВНИМАНИЕ
    Более высокий приоритет не означает, что 100% поток с таким приоритетом исполнится быстрее. Не полагайтесь на
    приоритет для распределения нагрузки между потоками.

    Передача управления другому потоку#
    Если текущий поток готов отдать свою часть процессорного времени другому потоку, то можно вызвать метод
    Thread.yield(). Вызов этого метода - это рекомендация планировщику потоков, но не строгое указание. На разных
    операционных системах поведение этого метода может отличаться. Приоритет потоков имеет значение при вызове метода
    yield(). Поток с более высоким приоритетом вероятней получит управление.

    Присоединение потоков#
    Нестатический метод join() позволяет присоединить один поток к другому. Текущий поток приостанавливает выполнение
    до того времени, пока не завершится поток, для которого был вызван метод join.
*/
class Test2 {
    public static void main(String[] args) throws InterruptedException {
        Thread helloThread = new Thread(() -> System.out.println("Hello"));
        //Thread thread = new ThreadSubClass();
        helloThread.start();
        helloThread.join(); //поток Main будет выполнен после завершения работы потока thread
    }
}
/*

    Потоки-демоны#
    Поток-демон - это служебный поток. Задача этого потока - обслуживание других потоков. Сделать поток демоном можно
    вызвав метод setDaemon(true). Проверить, не является ли поток демоном, можно методом isDaemon().

    Особенность потока-демона - программа не ждет завершения потоков-демонов. Если исполняются лишь потоки-демоны, то
    Java-машина завершит исполнение такой программы.
*/